// src/openai/streaming.ts
import { Stream } from "openai/streaming";

// src/openai/mergeChunks.ts
var omit = (obj, ...keys) => {
  const ret = { ...obj };
  for (const key of keys) {
    delete ret[key];
  }
  return ret;
};
function mergeChunks(base, chunk) {
  if (base === null) {
    return mergeChunks(
      { ...chunk, object: "chat.completion", choices: [], usage: chunk.usage ?? void 0 },
      // Prevent function call and tool call arguments from being double-merged
      {
        ...chunk,
        choices: chunk.choices.map((c) => ({
          ...c,
          delta: {
            ...c.delta,
            function_call: c.delta.function_call ? {
              ...c.delta.function_call
            } : void 0,
            tool_calls: c.delta.tool_calls?.map((tc) => ({
              ...tc,
              function: {
                ...tc.function
              }
            }))
          }
        }))
      }
    );
  }
  const choices = [...base.choices];
  for (const choice of chunk.choices) {
    const baseChoice = choices.find((c) => c.index === choice.index);
    if (baseChoice) {
      baseChoice.finish_reason = choice.finish_reason ?? baseChoice.finish_reason;
      baseChoice.message = { ...baseChoice.message, refusal: null };
      if (choice.delta?.content)
        baseChoice.message.content = (baseChoice.message.content ?? "") + (choice.delta.content ?? "");
      if (choice.delta?.function_call) {
        const fnCall = baseChoice.message.function_call ?? {
          name: "",
          arguments: ""
        };
        fnCall.name = fnCall.name + (choice.delta.function_call.name ?? "");
        fnCall.arguments = fnCall.arguments + (choice.delta.function_call.arguments ?? "");
      }
      if (choice.delta?.tool_calls) {
        const toolCalls = baseChoice.message.tool_calls ?? [];
        const toolCallDelta = { ...choice.delta.tool_calls[0] };
        if (toolCallDelta?.function?.name) {
          toolCalls.push({
            id: toolCallDelta.id,
            type: "function",
            function: {
              name: toolCallDelta.function.name ?? "",
              arguments: toolCallDelta.function.arguments ?? ""
            }
          });
        } else if (toolCalls[toolCalls.length - 1] && toolCallDelta) {
          toolCalls[toolCalls.length - 1].function.arguments += toolCallDelta.function?.arguments ?? "";
        }
        baseChoice.message.tool_calls = toolCalls;
      }
    } else {
      choices.push({ ...omit(choice, "delta"), message: { role: "assistant", ...choice.delta } });
    }
  }
  const merged = {
    ...base,
    choices,
    usage: chunk.usage ?? void 0
  };
  return merged;
}

// src/openai/streaming.ts
var WrappedStream = class extends Stream {
  constructor(stream, report) {
    super(stream.iterator, stream.controller);
    this.resolveReportingFinished = () => {
    };
    this.report = report;
    const reportingFinished = new Promise((resolve) => {
      this.resolveReportingFinished = resolve;
    });
    this.openpipe = {
      reportingFinished
    };
  }
  async *[Symbol.asyncIterator]() {
    const iterator = super[Symbol.asyncIterator]();
    let combinedResponse = null;
    while (true) {
      const result = await iterator.next();
      if (result.done) break;
      combinedResponse = mergeChunks(combinedResponse, result.value);
      yield result.value;
    }
    await this.report(combinedResponse);
    this.resolveReportingFinished();
  }
};
export {
  WrappedStream
};
//# sourceMappingURL=streaming.js.map